{"version":3,"sources":["DeviceCard.tsx","MiBluetoothDevice.tsx","Configuration.tsx","App.tsx","serviceWorker.ts","index.tsx","Configuration.module.css","App.module.css"],"names":["DeviceCard","observer","handleToggleConnect","props","device","gattConnected","disconnect","toggleConnecting","connect","then","this","connected","interactive","name","disabled","connecting","checked","onChange","React","Component","observable","action","MiBluetoothDevice","_device","id","onDisconnected","event","target","updateDevice","a","console","warn","gatt","gattServer","log","catch","error","addEventListener","Error","Configuration","addDevice","navigator","bluetooth","requestDevice","acceptAllDevices","runInAction","currentDevice","devices","get","set","getAvailability","isBluetoothAvailable","updateBluetoothAvailability","value","forEach","push","key","className","css","configuration","bluetoothAvailable","addButton","fill","minimal","onClick","icon","iconSize","intent","title","ObservableMap","available","App","Helmet","content","fixedToTop","styles","toBottom","Group","align","center","Heading","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","ReactDOM","render","StrictMode","document","getElementById","URL","process","href","origin","fetch","headers","response","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker","module","exports"],"mappings":"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","file":"static/js/main.a9597f23.chunk.js","sourcesContent":["import React from \"react\";\n\nimport { Card, Switch } from \"@blueprintjs/core\";\nimport { observer } from \"mobx-react\";\nimport { observable, action } from \"mobx\";\nimport { MiBluetoothDevice } from \"./MiBluetoothDevice\";\n\ninterface Props {\n  device: MiBluetoothDevice;\n  connected?: boolean;\n}\n\n@observer\nexport default class DeviceCard extends React.Component<Props> {\n  @observable connecting: boolean = false;\n\n  @action toggleConnecting = () => (this.connecting = !this.connecting);\n\n  handleToggleConnect = () => {\n    if (this.props.device.gattConnected) {\n      this.props.device.disconnect();\n    } else {\n      this.toggleConnecting();\n      this.props.device.connect().then(this.toggleConnecting);\n    }\n  };\n\n  render() {\n    const { device, connected } = this.props;\n\n    return (\n      <Card interactive={true}>\n        <h5>{device.name}</h5>\n        <Switch\n          disabled={this.connecting}\n          checked={connected}\n          onChange={this.handleToggleConnect}\n        />\n      </Card>\n    );\n  }\n}\n","import { observable, action } from \"mobx\";\n\nexport class MiBluetoothDevice {\n  _device: BluetoothDevice;\n  id: BluetoothDevice[\"id\"];\n  name: BluetoothDevice[\"name\"];\n  @observable gattConnected: boolean;\n  constructor(device: BluetoothDevice) {\n    this._device = device;\n    this.id = device.id;\n    this.name = device.name;\n    this.gattConnected = device.gatt?.connected || false;\n    device.addEventListener(\"gattserverdisconnected\", this.onDisconnected);\n  }\n\n  @action updateDevice(device: BluetoothDevice) {\n    if (device.id !== this.id) {\n      throw new Error(\n        `Trying to update device ${this.id} with data from other device ${device.id}`\n      );\n    }\n    this._device = device;\n    this.gattConnected = device.gatt?.connected || false;\n  }\n\n  onDisconnected = (event: Event) => {\n    const device: BluetoothDevice = event.target as any;\n    this.updateDevice(device);\n  };\n\n  connect = async () => {\n    if (this.gattConnected) {\n      console.warn(\n        `Trying to connect allready connected gatt server ${this.id}`\n      );\n      return true;\n    }\n    return this._device.gatt\n      ?.connect()\n      .then((gattServer) => {\n        console.log(gattServer);\n        this.updateDevice(gattServer.device);\n        return true;\n      })\n      .catch((error) => {\n        console.error(\"Error while trying to connect \", this.name);\n        console.error(error);\n        return false;\n      });\n  };\n\n  disconnect = () => {\n    this._device.gatt?.disconnect();\n  };\n}\n","import React, { ReactElement } from \"react\";\n\nimport { observer } from \"mobx-react\";\nimport { observable, ObservableMap, runInAction, action } from \"mobx\";\n\nimport { Button, Icon, NonIdealState } from \"@blueprintjs/core\";\n\nimport DeviceCard from \"./DeviceCard\";\nimport { MiBluetoothDevice } from \"./MiBluetoothDevice\";\n\nimport css from \"./Configuration.module.css\";\n\n@observer\nexport default class Configuration extends React.Component {\n  @observable devices: ObservableMap<\n    string,\n    MiBluetoothDevice\n  > = new ObservableMap();\n\n  @observable bluetoothAvailable: boolean = false;\n\n  addDevice = () => {\n    navigator.bluetooth\n      .requestDevice({ acceptAllDevices: true })\n      .then((device) =>\n        runInAction(() => {\n          const currentDevice = this.devices.get(device.id);\n          if (currentDevice) {\n            currentDevice.updateDevice(device);\n          } else {\n            this.devices.set(device.id, new MiBluetoothDevice(device));\n          }\n        })\n      )\n      .catch((error) => {\n        console.log(error);\n      });\n  };\n\n  @action updateBluetoothAvailability = (available: boolean) =>\n    (this.bluetoothAvailable = available);\n\n  componentDidMount() {\n    if (\"bluetooth\" in navigator) {\n      navigator.bluetooth.getAvailability().then((isBluetoothAvailable) => {\n        console.log(\n          `> Bluetooth is ${isBluetoothAvailable ? \"available\" : \"unavailable\"}`\n        );\n        this.updateBluetoothAvailability(isBluetoothAvailable);\n      });\n\n      if (\"onavailabilitychanged\" in navigator.bluetooth) {\n        navigator.bluetooth.addEventListener(\"availabilitychanged\", (event) => {\n          console.log(\n            `> Bluetooth is ${\n              (event as any).value ? \"available\" : \"unavailable\"\n            }`\n          );\n          this.updateBluetoothAvailability((event as any).value);\n        });\n      }\n    }\n  }\n\n  render() {\n    const devices: Array<ReactElement> = [];\n    this.devices.forEach((device) => {\n      //console.log(device.name, \" connected \", device.gatt?.connected);\n\n      devices.push(<DeviceCard key={device.id} device={device} />);\n    });\n\n    return (\n      <div className={css.configuration}>\n        <div className={css.devices}>{devices}</div>\n        {this.bluetoothAvailable ? (\n          <Button\n            className={css.addButton}\n            fill\n            minimal\n            onClick={this.addDevice}\n          >\n            <Icon icon=\"add\" iconSize={100} intent=\"primary\" />\n          </Button>\n        ) : (\n          <NonIdealState icon=\"offline\" title=\"Bluetooth is not available\" />\n        )}\n      </div>\n    );\n  }\n}\n","import React from \"react\";\n\nimport { Helmet } from \"react-helmet\";\nimport { Navbar } from \"@blueprintjs/core\";\n\nimport Configuration from \"./Configuration\";\n\nimport styles from \"./App.module.css\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <>\n      <Helmet>\n        <title>Blue hoofs</title>\n        <meta name=\"description\" content=\"Mi band 2 for hoofs friends\" />\n      </Helmet>\n      <Configuration />\n      <Navbar fixedToTop className={styles.toBottom}>\n        <Navbar.Group align=\"center\" className={styles.center}>\n          <Navbar.Heading>Blue hoofs</Navbar.Heading>\n        </Navbar.Group>\n      </Navbar>\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n//  Work offline and load faster\n// Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"configuration\":\"Configuration_configuration__1O6ua\",\"addButton\":\"Configuration_addButton__27U5I\",\"devices\":\"Configuration_devices__1LPi9\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"toBottom\":\"App_toBottom__gEblt\",\"center\":\"App_center__3oPdq\"};"],"sourceRoot":""}